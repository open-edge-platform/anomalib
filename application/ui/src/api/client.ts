import { isTauri } from '@tauri-apps/api/core';
import createFetchClient from 'openapi-fetch';
import createClient from 'openapi-react-query';

import type { paths } from './openapi-spec'; // generated by openapi-typescript

// In a Tauri webview the UI is served from tauri://localhost while the sidecar
// backend listens on http://localhost:8000 â€” a different origin.  We detect
// this at runtime so the same production bundle works in both Tauri (needs the
// absolute URL) and Docker/browser (same origin, relative paths are fine).

export const API_BASE_URL = import.meta.env.PUBLIC_API_BASE_URL || (isTauri() ? 'http://localhost:8000' : '');

export const fetchClient = createFetchClient<paths>({ baseUrl: API_BASE_URL });

export const $api = createClient(fetchClient);

/**
 * Constructs an API URL for direct fetch/EventSource/img calls that do not go
 * through fetchClient.
 * This helper exists because those call sites can otherwise resolve against
 * the UI origin (e.g. localhost:3000/api) instead of the backend origin
 * (e.g. localhost:8000/api), which breaks in the tauri application.
 *
 * Behavior:
 * - If API_BASE_URL is empty, returns path unchanged.
 * - Otherwise uses URL(path, API_BASE_URL), which normalizes slashes and keeps
 *   absolute path URLs intact.
 * - Falls back to normalized string joining if URL construction fails.
 */
export const getApiUrl = (path: string): string => {
    // Preserve existing behavior when no base URL is configured.
    if (!API_BASE_URL) {
        return path;
    }

    try {
        return new URL(path, API_BASE_URL).toString();
    } catch {
        const normalizedBase = API_BASE_URL.replace(/\/+$/, '');
        const normalizedPath = path.replace(/^\/+/, '');
        return `${normalizedBase}/${normalizedPath}`;
    }
};
